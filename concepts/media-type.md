---
layout:    page
title:     "Media Types"
permalink: /concepts/media-type/
---



The following 121 Media Type values (118 distinct values) were found in [all available `webconcepts.info` specifications](/specs). Please be advised that the table shown here is maintained and compiled from [Web Concepts](/) sources. The [official Media Type registry](http://www.iana.org/assignments/media-types/media-types.xhtml) is maintained by the [*Internet Assigned Numbers Authority (IANA)*](http://www.iana.org/).

Media Type | Specification
-------: | :-------
[`application/EmergencyCallData.Control+xml`](/concepts/media-type/application/EmergencyCallData.Control+xml "Pan-European eCall provides a standardized and mandated set of vehicle-related data (including VIN, vehicle type, propulsion type, current and optionally previous location coordinates, and the number of occupants) known as the Minimum Set of Data (MSD). The application/EmergencyCallData.Control+xml media type enables the metadata/control data to be carried in SIP.") | [**RFC 8147**: Next-Generation Pan-European eCall](/specs/IETF/RFC/8147 "This document describes how to use IP-based emergency services mechanisms to support the next generation of the Pan-European in-vehicle emergency call service defined under the eSafety initiative of the European Commission (generally referred to as &#34;eCall&#34;). eCall is a standardized and mandated system for a special form of emergency calls placed by vehicles, providing real-time communications and an integrated set of related data. This document also registers MIME media types and an Emergency Call Data Type for the eCall vehicle data and metadata/control data, and an INFO package to enable carrying this data in SIP INFO requests. Although this specification is designed to meet the requirements of next-generation Pan-European eCall (NG-eCall), it is specified generically such that the technology can be reused or extended to suit requirements across jurisdictions.")
[`application/EmergencyCallData.eCall.MSD`](/concepts/media-type/application/EmergencyCallData.eCall.MSD "Pan-European eCall provides a standardized and mandated set of vehicle-related data (including VIN, vehicle type, propulsion type, current and optionally previous location coordinates, and the number of occupants) known as the Minimum Set of Data (MSD). The application/EmergencyCallData.eCall.MSD media type enables the MSD to be carried in SIP.") | [**RFC 8147**: Next-Generation Pan-European eCall](/specs/IETF/RFC/8147 "This document describes how to use IP-based emergency services mechanisms to support the next generation of the Pan-European in-vehicle emergency call service defined under the eSafety initiative of the European Commission (generally referred to as &#34;eCall&#34;). eCall is a standardized and mandated system for a special form of emergency calls placed by vehicles, providing real-time communications and an integrated set of related data. This document also registers MIME media types and an Emergency Call Data Type for the eCall vehicle data and metadata/control data, and an INFO package to enable carrying this data in SIP INFO requests. Although this specification is designed to meet the requirements of next-generation Pan-European eCall (NG-eCall), it is specified generically such that the technology can be reused or extended to suit requirements across jurisdictions.")
[`application/activity+json`](/concepts/media-type/application/activity+json "In the most basic sense, an &#34;activity&#34; is a semantic description of a potential or completed action. In the former case, the activity expresses what can or might be done with a particular object, while in the latter case, it expresses what has already been done. It is the goal of this specification to provide a JSON-based syntax that is sufficient to express metadata about activities in a rich, human-friendly, machine-processable and extensible manner. This may include constructing natural-language descriptions or visual representations about the activity, associating actionable information with various types of objects, communicating or recording activity logs, or delegation of potential actions to other applications.") | [**W3C TR http://www.w3.org/TR/activitystreams-core**: Activity Streams 2.0](/specs/W3C/TR/activitystreams-core "This specification details a model for representing potential and completed activities using the JSON format.")
[`application/alps+json`](/concepts/media-type/application/alps+json "When representing ALPS documents in JSON format, the 'descriptor' and 'ext' properties are always expressed as arrays of anonymous objects - even when there is only one member in the array.") | [**Internet Draft amundsen-richardson-foster-alps**: Application-Level Profile Semantics (ALPS)](/specs/IETF/I-D/amundsen-richardson-foster-alps "This document describes ALPS, a data format for defining simple descriptions of application-level semantics, similar in complexity to HTML microformats. An ALPS document can be used as a profile to explain the application semantics of a document with an application-agnostic media type (such as HTML, HAL, Collection+JSON, Siren, etc.). This increases the reusability of profile documents across media types.")
[`application/alps+xml`](/concepts/media-type/application/alps+xml "In the XML version of an ALPS document, the following ALPS properties always appear as XML elements: 'alps', 'doc', 'descriptor', and 'ext'. All other ALPS properties appear as XML attributes.") | [**Internet Draft amundsen-richardson-foster-alps**: Application-Level Profile Semantics (ALPS)](/specs/IETF/I-D/amundsen-richardson-foster-alps "This document describes ALPS, a data format for defining simple descriptions of application-level semantics, similar in complexity to HTML microformats. An ALPS document can be used as a profile to explain the application semantics of a document with an application-agnostic media type (such as HTML, HAL, Collection+JSON, Siren, etc.). This increases the reusability of profile documents across media types.")
[`application/atom+xml`](/concepts/media-type/application/atom+xml "This specification describes two kinds of Atom Documents: Atom Feed Documents and Atom Entry Documents. Both kinds of Atom Documents are specified in terms of the XML Information Set, serialized as XML 1.0 and identified with the &#34;application/atom+xml&#34; media type. Atom Documents MUST be well-formed XML.") | [**RFC 4287**: Atom Syndication Format](/specs/IETF/RFC/4287 "Atom is an XML-based document format that describes lists of related information known as &#34;feeds&#34;. Feeds are composed of a number of items, known as &#34;entries&#34;, each with an extensible set of attached metadata. For example, each entry has a title.")
[`application/atomcat+xml`](/concepts/media-type/application/atomcat+xml "An Atom Publishing Protocol Category Document, when serialized as XML 1.0, can be identified with the following media type.") | [**RFC 5023**: Atom Publishing Protocol (AtomPub)](/specs/IETF/RFC/5023 "The Atom Publishing Protocol (AtomPub) is an application-level protocol for publishing and editing Web resources. The protocol is based on HTTP transfer of Atom-formatted representations. The Atom format is documented in the Atom Syndication Format.")
[`application/atomdeleted+xml`](/concepts/media-type/application/atomdeleted+xml "A &#34;Deleted Entry Document&#34; represents exactly one at:deleted-entry element outside the context of an Atom feed. Its root is the at:deleted-entry element.") | [**RFC 6271**: The Atom "deleted-entry" Element](/specs/IETF/RFC/6271 "This specification adds mechanisms to the Atom Syndication Format that publishers of Atom Feed and Entry documents can use to explicitly identify Atom entries that have been removed.")
[`application/atomsvc+xml`](/concepts/media-type/application/atomsvc+xml "An Atom Publishing Protocol Service Document, when serialized as XML 1.0, can be identified with the following media type.") | [**RFC 5023**: Atom Publishing Protocol (AtomPub)](/specs/IETF/RFC/5023 "The Atom Publishing Protocol (AtomPub) is an application-level protocol for publishing and editing Web resources. The protocol is based on HTTP transfer of Atom-formatted representations. The Atom format is documented in the Atom Syndication Format.")
[`application/auth-policy+xml`](/concepts/media-type/application/auth-policy+xml "This document defines a framework for authorization policies controlling access to application-specific data. This framework combines common location- and presence-specific authorization aspects. An XML schema specifies the language in which common policy rules are represented. The common policy framework can be extended to other application domains.") | [**RFC 4745**: Common Policy: A Document Format for Expressing Privacy Preferences](/specs/IETF/RFC/4745 "This document defines a framework for authorization policies controlling access to application-specific data. This framework combines common location- and presence-specific authorization aspects. An XML schema specifies the language in which common policy rules are represented. The common policy framework can be extended to other application domains.")
[`application/cbor`](/concepts/media-type/application/cbor "CBOR follows some specific design goals that are not well met by current binary formats. The underlying data model is an extended version of the JSON data model.") | [**RFC 7049**: Concise Binary Object Representation (CBOR)](/specs/IETF/RFC/7049 "The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.")
[`application/coap-group+json`](/concepts/media-type/application/coap-group+json "CoAP endpoints implementing the membership configuration RESTful interface MUST support the CoAP group configuration Internet Media Type &#34;application/coap-group+json&#34;.") | [**RFC 7390**: Group Communication for the Constrained Application Protocol (CoAP)](/specs/IETF/RFC/7390 "The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for constrained devices and constrained networks. It is anticipated that constrained devices will often naturally operate in groups (e.g., in a building automation scenario, all lights in a given room may need to be switched on/off as a group). This specification defines how CoAP should be used in a group communication context.  An approach for using CoAP on top of IP multicast is detailed based on existing CoAP functionality as well as new features introduced in this specification.  Also, various use cases and corresponding protocol flows are provided to illustrate important concepts.  Finally, guidance is provided for deployment in various network topologies.")
[`application/coap-payload`](/concepts/media-type/application/coap-payload "This media type represents any payload that a CoAP message can carry, having a content format that can be identified by a CoAP Content-Format parameter (an integer in range 0-65535). The parameter &#34;cf&#34; is the integer defining the CoAP content format.") | [**Internet Draft ietf-core-http-mapping**: Guidelines for HTTP-to-CoAP Mapping Implementations](/specs/IETF/I-D/ietf-core-http-mapping "This document provides reference information for implementing a cross-protocol network proxy that performs translation from the HTTP protocol to the CoAP protocol. This will enable a HTTP client to access resources on a CoAP server through the proxy. This document describes how a HTTP request is mapped to a CoAP request, and then how a CoAP response is mapped back to a HTTP response. This includes guidelines for URI mapping, media type mapping and additional proxy implementation issues. This document covers the Reverse, Forward and Interception cross-protocol proxy cases.")
[`application/cose`](/concepts/media-type/application/cose "The &#34;application/cose&#34; media type is used to indicate that the content is a COSE message.") | [**RFC 8152**: CBOR Object Signing and Encryption (COSE)](/specs/IETF/RFC/8152 "Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need for the ability to have basic security services defined for this data format. This document defines the CBOR Object Signing and Encryption (COSE) protocol. This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization. This specification additionally describes how to represent cryptographic keys using CBOR.")
[`application/cose-key`](/concepts/media-type/application/cose-key "The &#34;application/cose-key&#34; media type is used to indicate that content is a COSE_Key object.") | [**RFC 8152**: CBOR Object Signing and Encryption (COSE)](/specs/IETF/RFC/8152 "Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need for the ability to have basic security services defined for this data format. This document defines the CBOR Object Signing and Encryption (COSE) protocol. This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization. This specification additionally describes how to represent cryptographic keys using CBOR.")
[`application/cose-key-set`](/concepts/media-type/application/cose-key-set "The &#34;application/cose-key&#34; media type is used to indicate that content is a COSE_KeySet object.") | [**RFC 8152**: CBOR Object Signing and Encryption (COSE)](/specs/IETF/RFC/8152 "Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need for the ability to have basic security services defined for this data format. This document defines the CBOR Object Signing and Encryption (COSE) protocol. This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization. This specification additionally describes how to represent cryptographic keys using CBOR.")
[`application/csrattrs`](/concepts/media-type/application/csrattrs "Responses to attribute request messages MUST be encoded as the content-type of &#34;application/csrattrs&#34; with a Content-Transfer-Encoding of &#34;base64&#34;.") | [**RFC 7030**: Enrollment over Secure Transport](/specs/IETF/RFC/7030 "This document profiles certificate enrollment for clients using Certificate Management over CMS (CMC) messages over a secure transport. This profile, called Enrollment over Secure Transport (EST), describes a simple, yet functional, certificate management protocol targeting Public Key Infrastructure (PKI) clients that need to acquire client certificates and associated Certification Authority (CA) certificates. It also supports client-generated public/private key pairs as well as key pairs generated by the CA.")
[`application/cwt`](/concepts/media-type/application/cwt "How to determine that a CBOR data structure is a CWT is application-dependent. In some cases, this information is known from the application context, such as from the position of the CWT in a data structure at which the value must be a CWT. One method of indicating that a CBOR object is a CWT is the use of the &#34;application/cwt&#34; content type by a transport protocol.") | [**RFC 8392**: CBOR Web Token (CWT)](/specs/IETF/RFC/8392 "CBOR Web Token (CWT) is a compact means of representing claims to be transferred between two parties. The claims in a CWT are encoded in the Concise Binary Object Representation (CBOR), and CBOR Object Signing and Encryption (COSE) is used for added application-layer security protection. A claim is a piece of information asserted about a subject and is represented as a name/value pair consisting of a claim name and a claim value. CWT is derived from JSON Web Token (JWT) but uses CBOR rather than JSON.")
[`application/dash+xml`](/concepts/media-type/application/dash+xml "&#34;application/dash+xml&#34; is the formal MIME type registration for the MPD. The Media Presentation Description (MPD) is a document that contains metadata required by a DASH Client to construct appropriate HTTP-URLs to access Segments and to provide the streaming service to the user.") | [**ISO/IEC 23009**: Information technology — Dynamic adaptive streaming over HTTP (DASH) — Part 1: Media presentation description and segment formats](/specs/ISO/IEC/23009 "ISO/IEC 23009-1:2014 primarily specifies formats for the Media Presentation Description and Segments for dynamic adaptive streaming delivery of MPEG media over HTTP. It is applicable to streaming services over the Internet.")
[`application/exi`](/concepts/media-type/application/exi "A new media type registration &#34;application/exi&#34; described below is being proposed for community review, with the intent to eventually submit it to the IESG for review, approval, and registration with IANA.") | [**W3C TR http://www.w3.org/TR/exi**: Efficient XML Interchange (EXI) Format 1.0](/specs/W3C/TR/exi "This document is the specification of the Efficient XML Interchange (EXI) format. EXI is a very compact representation for the Extensible Markup Language (XML) Information Set that is intended to simultaneously optimize performance and the utilization of computational resources. The EXI format uses a hybrid approach drawn from the information and formal language theories, plus practical techniques verified by measurements, for entropy encoding XML information. Using a relatively simple algorithm, which is amenable to fast and compact implementation, and a small set of datatype representations, it reliably produces efficient encodings of XML event streams. The grammar production system and format definition of EXI are presented.")
[`application/font-sfnt`](/concepts/media-type/application/font-sfnt "An Open font file contains data, in table format, that comprises either a TrueType or a PostScript outline font. Rasterizers use combinations of data from the tables contained in the font to render the TrueType or PostScript glyph outlines. Some of this supporting data is used no matter which outline format is used; some of the supporting data is specific to either TrueType or PostScript.") | [**ISO/IEC 14496**: Information technology — Coding of audio-visual objects — Part 22: Open Font Format](/specs/ISO/IEC/14496 "ISO/IEC 14496-22:2015 specifies the Open Font Format (OFF) specification, the TrueType and Compact Font Format (CFF) outline formats, and the TrueType hinting language. Many references to both TrueType and PostScript exist throughout this document, as Open Font Format fonts combine the two technologies.")
[`application/geo+json`](/concepts/media-type/application/geo+json "The media type for GeoJSON text is &#34;application/geo+json&#34;. The entry for &#34;application/vnd.geo+json&#34; in the same registry should have its status changed to be Obsolete with a pointer to the media type &#34;application/geo+json&#34; and a reference added to this RFC.") | [**RFC 7946**: The GeoJSON Format](/specs/IETF/RFC/7946 "GeoJSON is a geospatial data interchange format based on JavaScript Object Notation (JSON). It defines several types of JSON objects and the manner in which they are combined to represent data about geographic features, their properties, and their spatial extents. GeoJSON uses a geographic coordinate reference system, World Geodetic System 1984, and units of decimal degrees.")
[`application/geo+json-seq`](/concepts/media-type/application/geo+json-seq "A GeoJSON text sequence is any number of GeoJSON texts, each encoded in UTF-8, each preceded by one ASCII RS character, and each followed by a line feed (LF).") | [**RFC 8142**: GeoJSON Text Sequences](/specs/IETF/RFC/8142 "This document describes the GeoJSON text sequence format and &#34;application/geo+json-seq&#34; media type. This format is based on JavaScript Object Notation (JSON) Text Sequences and GeoJSON, and makes arbitrarily large geographic datasets incrementally parseable without restricting the form of GeoJSON texts within a sequence.")
[`application/gzip`](/concepts/media-type/application/gzip "The 'application/gzip' media type describes a block of data that is compressed using gzip compression. The data is a stream of bytes as described in RFC 1952.") | [**RFC 6713**: The 'application/zlib' and 'application/gzip' Media Types](/specs/IETF/RFC/6713 "This document defines the 'application/gzip' and 'application/zlib' media types for compressed data using the gzip and zlib compression formats.")
[`application/hal+json`](/concepts/media-type/application/hal+json "HAL is a generic media type with which Web APIs can be developed and exposed as series of links. Clients of these APIs can select links by their link relation type and traverse them in order to progress through the application.") | [**Internet Draft kelly-json-hal**: JSON Hypertext Application Language](/specs/IETF/I-D/kelly-json-hal "This document proposes a media type for representing resources and their relations with hyperlinks.")
[`application/hal+xml`](/concepts/media-type/application/hal+xml "The XML Hypertext Application Language (HAL) is a standard which establishes conventions for expressing hypermedia controls, such as links, with XML. HAL is a generic media type with which Web APIs can be developed and exposed as series of links. Clients of these APIs can select links by their link relation type and traverse them in order to progress through the application.") | [**Internet Draft michaud-xml-hal**: XML Hypertext Application Language](/specs/IETF/I-D/michaud-xml-hal "This document proposes a media type for representing resources and their relations with hyperlinks.")
[`application/held+xml`](/concepts/media-type/application/held+xml "This section gives the XML Schema Definition of the &#34;application/held+xml&#34; format. This is presented as a formal definition of the &#34;application/held+xml&#34; format. Note that the XML Schema Definition is not intended to be used with on-the-fly validation of the presence XML document.") | [**RFC 5985**: HTTP-Enabled Location Delivery (HELD)](/specs/IETF/RFC/5985 "This document defines a Layer 7 Location Configuration Protocol (L7 LCP) and describes the use of HTTP and HTTP/TLS as transports for the L7 LCP. The L7 LCP is used for retrieving location information from a server within an access network. It includes options for retrieving location information in two forms: by value and by reference. The protocol is an extensible application-layer protocol that is independent of the session layer.")
[`application/home+json`](/concepts/media-type/application/home+json "This document proposes a &#34;home document&#34; format for non-browser HTTP clients.") | [**Internet Draft nottingham-json-home**: Home Documents for HTTP APIs](/specs/IETF/I-D/nottingham-json-home "This document proposes a &#34;home document&#34; format for non-browser HTTP clients.")
[`application/home+xml`](/concepts/media-type/application/home+xml "The specification for HTTP Home Documents provides a JSON syntax only. This media type provides an XML syntax for the same underlying data model, so that the concept of HTTP Home Documents can be consistently exposed in both JSON- and XML-based HTTP services.") | [**Internet Draft wilde-home-xml**: Home Documents for HTTP Services: XML Syntax](/specs/IETF/I-D/wilde-home-xml "The specification for HTTP API Home Documents provides a JSON syntax only. This specification provides an XML syntax for the same data model, so that the concept of Home Documents can be consistently exposed in both JSON- and XML-based HTTP APIs. It also defines the link relation type &#34;home&#34; so that applications can identify links to home documents.")
[`application/http`](/concepts/media-type/application/http "The application/http type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed).") | [**RFC 7230**: Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing](/specs/IETF/RFC/7230 "The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypertext information systems. HTTP has been in use by the World Wide Web global information initiative since 1990. This document provides an overview of HTTP architecture and its associated terminology, defines the &#34;http&#34; and &#34;https&#34; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes general security concerns for implementations.")
[`application/jose`](/concepts/media-type/application/jose "The &#34;application/jose&#34; media type can be used to indicate that the content is a JWS or JWE using the JWS Compact Serialization or the JWE Compact Serialization.") | [**RFC 7515**: JSON Web Signature (JWS)](/specs/IETF/RFC/7515 "JSON Web Signature (JWS) represents content secured with digital signatures or Message Authentication Codes (MACs) using JSON-based data structures. Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and an IANA registry defined by that specification. Related encryption capabilities are described in the separate JSON Web Encryption (JWE) specification.")
[`application/jose+json`](/concepts/media-type/application/jose+json "The &#34;application/jose+json&#34; media type can be used to indicate that the content is a JWS or JWE using the JWS JSON Serialization or the JWE JSON Serialization.") | [**RFC 7515**: JSON Web Signature (JWS)](/specs/IETF/RFC/7515 "JSON Web Signature (JWS) represents content secured with digital signatures or Message Authentication Codes (MACs) using JSON-based data structures. Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and an IANA registry defined by that specification. Related encryption capabilities are described in the separate JSON Web Encryption (JWE) specification.")
[`application/jrd+json`](/concepts/media-type/application/jrd+json "The WebFinger resource returns a JSON Resource Descriptor (JRD) as the resource representation to convey information about an entity on the Internet.") | [**RFC 7033**: WebFinger](/specs/IETF/RFC/7033 "This specification defines the WebFinger protocol, which can be used to discover information about people or other entities on the Internet using standard HTTP methods. WebFinger discovers information for a URI that might not be usable as a locator otherwise, such as account or email URIs.")
[`application/json`](/concepts/media-type/application/json "JavaScript Object Notation (JSON) is a text format for the serialization of structured data. It is derived from the object literals of JavaScript, as defined in the ECMAScript Programming Language Standard, Third Edition.")<sub title="There are 2 definitions for this value">2</sub> | [**RFC 8259**: JavaScript Object Notation (JSON)](/specs/IETF/RFC/8259 "JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data. This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.")<br/>[**Internet Draft ietf-jsonbis-rfc7159bis**: The JavaScript Object Notation (JSON) Data Interchange Format](/specs/IETF/I-D/ietf-jsonbis-rfc7159bis "JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data. This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.")
[`application/json-patch+json`](/concepts/media-type/application/json-patch+json "A JSON Patch document is a JSON [RFC4627] document that represents an array of objects. Each object represents a single operation to be applied to the target JSON document.") | [**RFC 6902**: JavaScript Object Notation (JSON) Patch](/specs/IETF/RFC/6902 "JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JavaScript Object Notation (JSON) document; it is suitable for use with the HTTP PATCH method. The &#34;application/json-patch+json&#34; media type is used to identify such patch documents.")
[`application/json-seq`](/concepts/media-type/application/json-seq "&#34;JSON text sequences&#34; are specifically not JSON texts themselves but are composed of (possible) JSON texts. JSON text sequences can be parsed (and produced) incrementally without having to have a streaming parser (nor streaming encoder).") | [**RFC 7464**: JavaScript Object Notation (JSON) Text Sequences](/specs/IETF/RFC/7464 "This document describes the JavaScript Object Notation (JSON) text sequence format and associated media type &#34;application/json-seq&#34;. A JSON text sequence consists of any number of JSON texts, all encoded in UTF-8, each prefixed by an ASCII Record Separator (0x1E), and each ending with an ASCII Line Feed character (0x0A).")
[`application/jwk+json`](/concepts/media-type/application/jwk+json "A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value.") | [**RFC 7517**: JSON Web Key (JWK)](/specs/IETF/RFC/7517 "A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. This specification also defines a JWK Set JSON data structure that represents a set of JWKs. Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and IANA registries established by that specification.")
[`application/jwk-set+json`](/concepts/media-type/application/jwk-set+json "A JWK Set is a JSON object that represents a set of JWKs. The JSON object MUST have a &#34;keys&#34; member, with its value being an array of JWKs.") | [**RFC 7517**: JSON Web Key (JWK)](/specs/IETF/RFC/7517 "A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. This specification also defines a JWK Set JSON data structure that represents a set of JWKs. Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and IANA registries established by that specification.")
[`application/jwt`](/concepts/media-type/application/jwt "The JWT Claims Set represents a JSON object whose members are the claims conveyed by the JWT.") | [**RFC 7519**: JSON Web Token (JWT)](/specs/IETF/RFC/7519 "JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted.")
[`application/ld+json`](/concepts/media-type/application/ld+json "Generally speaking, the data model used for JSON-LD is a labeled, directed graph. The graph contains nodes, which are connected by edges. A node is typically data such as a string, number, typed values (like dates and times) or an IRI. There is also a special class of node called a blank node, which is typically used to express data that does not have a global identifier like an IRI. Blank nodes are identified using a blank node identifier.") | [**W3C TR http://www.w3.org/TR/json-ld**: JSON-LD 1.0](/specs/W3C/TR/json-ld "JSON is a useful data serialization and messaging format. This specification defines JSON-LD, a JSON-based format to serialize Linked Data. The syntax is designed to easily integrate into deployed systems that already use JSON, and provides a smooth upgrade path from JSON to JSON-LD. It is primarily intended to be a way to use Linked Data in Web-based programming environments, to build interoperable Web services, and to store Linked Data in JSON-based storage engines.")
[`application/link-format`](/concepts/media-type/application/link-format "The CoRE Link Format extends the HTTP Link Header field specified in RFC 5988.") | [**RFC 6690**: Constrained RESTful Environments (CoRE) Link Format](/specs/IETF/RFC/6690 "This specification defines Web Linking using a link format for use by constrained web servers to describe hosted resources, their attributes, and other relationships between links. Based on the HTTP Link Header field defined in RFC 5988, the Constrained RESTful Environments (CoRE) Link Format is carried as a payload and is assigned an Internet media type. &#34;RESTful&#34; refers to the Representational State Transfer (REST) architecture. A well-known URI is defined as a default entry point for requesting the links hosted by a server.")
[`application/link-format+cbor`](/concepts/media-type/application/link-format+cbor "An application/link-format document is a collection of web links, each of which is a collection of attributes applied to a &#34;URI-Reference&#34;. The application/link-format+cbor media type is a CBOR-based serialization of such a document.") | [**Internet Draft ietf-core-links-json**: Representing CoRE Formats in JSON and CBOR](/specs/IETF/I-D/ietf-core-links-json "JavaScript Object Notation (JSON) is a text-based data format which is popular for Web based data exchange. Concise Binary Object Representation (CBOR) is a binary data format which has been optimized for data exchange for the Internet of Things (IoT). For many IoT scenarios, CBOR formats will be preferred since it can help decrease transmission payload sizes as well as implementation code sizes compared to other data formats. Web Linking (RFC 5988) provides a way to represent links between Web resources as well as the relations expressed by them and attributes of such a link. In constrained networks, a collection of Web links can be exchanged in the CoRE link format (RFC 6690). Outside of constrained environments, it may be useful to represent these collections of Web links in JSON, and similarly, inside constrained environments, in CBOR. This specification defines a common format for this.")
[`application/link-format+json`](/concepts/media-type/application/link-format+json "An application/link-format document is a collection of web links, each of which is a collection of attributes applied to a &#34;URI-Reference&#34;. The application/link-format+json media type is a JSON-based serialization of such a document.") | [**Internet Draft ietf-core-links-json**: Representing CoRE Formats in JSON and CBOR](/specs/IETF/I-D/ietf-core-links-json "JavaScript Object Notation (JSON) is a text-based data format which is popular for Web based data exchange. Concise Binary Object Representation (CBOR) is a binary data format which has been optimized for data exchange for the Internet of Things (IoT). For many IoT scenarios, CBOR formats will be preferred since it can help decrease transmission payload sizes as well as implementation code sizes compared to other data formats. Web Linking (RFC 5988) provides a way to represent links between Web resources as well as the relations expressed by them and attributes of such a link. In constrained networks, a collection of Web links can be exchanged in the CoRE link format (RFC 6690). Outside of constrained environments, it may be useful to represent these collections of Web links in JSON, and similarly, inside constrained environments, in CBOR. This specification defines a common format for this.")
[`application/linkset`](/concepts/media-type/application/linkset "This document format is identical to the payload of the HTTP Link header. It is defined in Section 3 of RFC 5988bis, more specifically by its ABNF production rule for &#34;Link&#34; and subsequent ones.") | [**Internet Draft ietf-httpapi-linkset**: Linkset: Media Types and a Link Relation Type for Link Sets](/specs/IETF/I-D/ietf-httpapi-linkset "This specification defines two document formats and respective media types for representing sets of links as stand-alone resources. One format is JSON-based, the other aligned with the format for representing links in the HTTP &#34;Link&#34; header field. This specification also introduces a link relation type to support discovery of sets of links.")
[`application/linkset+json`](/concepts/media-type/application/linkset+json "For applications that prefer a JSON serialization of link set resources, the following definition provides a JSON serialization which is intended to faithfully reproduce the abstract model of RFC 5988bis.") | [**Internet Draft ietf-httpapi-linkset**: Linkset: Media Types and a Link Relation Type for Link Sets](/specs/IETF/I-D/ietf-httpapi-linkset "This specification defines two document formats and respective media types for representing sets of links as stand-alone resources. One format is JSON-based, the other aligned with the format for representing links in the HTTP &#34;Link&#34; header field. This specification also introduces a link relation type to support discovery of sets of links.")
[`application/mads+xml`](/concepts/media-type/application/mads+xml "An XML schema for an authority element set used to provide metadata about agents (people, organizations), events, and terms (topics, geographics, genres, etc.). It is a companion to MODS.") | [**RFC 6207**: The Media Types application/mods+xml, application/mads+xml, application/mets+xml, application/marcxml+xml, and application/sru+xml](/specs/IETF/RFC/6207 "This document specifies media types for the following formats: MODS (Metadata Object Description Schema), MADS (Metadata Authority Description Schema), METS (Metadata Encoding and Transmission Standard), MARCXML (MARC21 XML Schema), and the SRU (Search/Retrieve via URL Response Format) protocol response XML schema. These are all XML schemas providing representations of various forms of information including metadata and search results.")
[`application/manifest+json`](/concepts/media-type/application/manifest+json "A manifest is a JSON document that contains startup parameters and application defaults for when a web application is launched. A manifest consists of a top-level object that contains zero or more members.") | [**W3C TR http://www.w3.org/TR/appmanifest**: Manifest for Web Application](/specs/W3C/TR/appmanifest "This specification defines a JSON-based manifest that provides developers with a centralized place to put metadata associated with a web application. This includes, but is not limited to, the web application's name, links to icons, as well as the preferred URL to open when a user launches the web application. The manifest also allows developers to declare a default orientation for their web application, as well as providing the ability to set the display mode for the application (e.g., in fullscreen). Additionally, the manifest allows a developer to &#34;scope&#34; a web application to a URL. This restricts the URLs to which the application can be navigated and provides a means to &#34;deep link&#34; into a web application from other applications. Using this metadata, user agents can provide developers with means to create user experiences that are more comparable to that of a native application. In addition, this specification defines the manifest link type, which provides a declarative means for a document to be associated with a manifest.")
[`application/marc`](/concepts/media-type/application/marc "Since there are different flavors of MARC which would be processed by different applications, this content-type/subtype refers to the harmonized USMARC/CANMARC specification. Additional content-types/subtypes may be defined in the future (e.g. application/unimarc).") | [**RFC 2220**: The Application/MARC Content-type](/specs/IETF/RFC/2220 "This memorandum provides a mechanism for representing objects which are files of Machine-Readable Cataloging records (MARC). The MARC formats are standards for the representation and communication of bibliographic and related information. A MARC record contains metadata for an information resource following MARC format specifications.")
[`application/marcxml+xml`](/concepts/media-type/application/marcxml+xml "An XML schema for the direct XML representation of the MARC format (for which there already exists a media type, application/marc).") | [**RFC 6207**: The Media Types application/mods+xml, application/mads+xml, application/mets+xml, application/marcxml+xml, and application/sru+xml](/specs/IETF/RFC/6207 "This document specifies media types for the following formats: MODS (Metadata Object Description Schema), MADS (Metadata Authority Description Schema), METS (Metadata Encoding and Transmission Standard), MARCXML (MARC21 XML Schema), and the SRU (Search/Retrieve via URL Response Format) protocol response XML schema. These are all XML schemas providing representations of various forms of information including metadata and search results.")
[`application/merge-patch+json`](/concepts/media-type/application/merge-patch+json "The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content. A JSON merge patch document describes changes to be made to a target JSON document using a syntax that closely mimics the document being modified.") | [**RFC 7396**: JSON Merge Patch](/specs/IETF/RFC/7396 "This specification defines the JSON merge patch format and processing rules. The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content.")
[`application/mets+xml`](/concepts/media-type/application/mets+xml "An XML schema for encoding descriptive, administrative, and structural metadata regarding objects within a digital library.") | [**RFC 6207**: The Media Types application/mods+xml, application/mads+xml, application/mets+xml, application/marcxml+xml, and application/sru+xml](/specs/IETF/RFC/6207 "This document specifies media types for the following formats: MODS (Metadata Object Description Schema), MADS (Metadata Authority Description Schema), METS (Metadata Encoding and Transmission Standard), MARCXML (MARC21 XML Schema), and the SRU (Search/Retrieve via URL Response Format) protocol response XML schema. These are all XML schemas providing representations of various forms of information including metadata and search results.")
[`application/mods+xml`](/concepts/media-type/application/mods+xml "An XML schema for a bibliographic element set that may be used for a variety of purposes, and particularly for library applications.") | [**RFC 6207**: The Media Types application/mods+xml, application/mads+xml, application/mets+xml, application/marcxml+xml, and application/sru+xml](/specs/IETF/RFC/6207 "This document specifies media types for the following formats: MODS (Metadata Object Description Schema), MADS (Metadata Authority Description Schema), METS (Metadata Encoding and Transmission Standard), MARCXML (MARC21 XML Schema), and the SRU (Search/Retrieve via URL Response Format) protocol response XML schema. These are all XML schemas providing representations of various forms of information including metadata and search results.")
[`application/nlsml+xml`](/concepts/media-type/application/nlsml+xml "The Natural Language Semantics Markup Language (NLSML) is an XML data structure with elements and attributes designed to carry result information from recognizer (including enrollment) and verifier resources.") | [**RFC 6768**: Media Resource Control Protocol Version 2 (MRCPv2)](/specs/IETF/RFC/6768 "The Media Resource Control Protocol Version 2 (MRCPv2) allows client hosts to control media service resources such as speech synthesizers, recognizers, verifiers, and identifiers residing in servers on the network. MRCPv2 is not a &#34;stand-alone&#34; protocol -- it relies on other protocols, such as the Session Initiation Protocol (SIP), to coordinate MRCPv2 clients and servers and manage sessions between them, and the Session Description Protocol (SDP) to describe, discover, and exchange capabilities. It also depends on SIP and SDP to establish the media sessions and associated parameters between the media source or sink and the media server. Once this is done, the MRCPv2 exchange operates over the control session established above, allowing the client to control the media processing resources on the speech resource server.")
[`application/p2p-overlay+xml`](/concepts/media-type/application/p2p-overlay+xml "This specification defines a new content type &#34;application/p2p-overlay+xml&#34; for a MIME entity that contains overlay information.") | [**RFC 6940**: REsource LOcation And Discovery (RELOAD) Base Protocol](/specs/IETF/RFC/6940 "This specification defines REsource LOcation And Discovery (RELOAD), a peer-to-peer (P2P) signaling protocol for use on the Internet. A P2P signaling protocol provides its clients with an abstract storage and messaging service between a set of cooperating peers that form the overlay network. RELOAD is designed to support a P2P Session Initiation Protocol (P2PSIP) network, but can be utilized by other applications with similar requirements by defining new usages that specify the Kinds of data that need to be stored for a particular application. RELOAD defines a security model based on a certificate enrollment service that provides unique identities. NAT traversal is a fundamental service of the protocol. RELOAD also allows access from &#34;client&#34; nodes that do not need to route traffic or store data for others.")
[`application/patch-ops-error+xml`](/concepts/media-type/application/patch-ops-error+xml "A new MIME error format is defined for applications that require deterministic error handling when patching cannot be applied. It is anticipated that these error elements can be used within other MIME types that allow extension elements.") | [**RFC 5261**: An Extensible Markup Language (XML) Patch Operations Framework Utilizing XML Path Language (XPath) Selectors](/specs/IETF/RFC/5261 "Extensible Markup Language (XML) documents are widely used as containers for the exchange and storage of arbitrary data in today's systems. In order to send changes to an XML document, an entire copy of the new version must be sent, unless there is a means of indicating only the portions that have changed. This document describes an XML patch framework utilizing XML Path language (XPath) selectors. These selector values and updated new data content constitute the basis of patch operations described in this document. In addition to them, with basic <add>, <replace>, and <remove> directives a set of patches can then be applied to update an existing XML document.")
[`application/pdf`](/concepts/media-type/application/pdf "PDF is used to represent &#34;final form&#34; formatted documents. PDF pages may include text, images, graphics, and multimedia content such as video and audio. PDF is also capable of containing auxiliary structures, including annotations, bookmarks, file attachments, hyperlinks, logical structures, and metadata. These features are useful for navigation and building collections of related documents, as well as for reviewing and commenting on documents.") | [**RFC 8118**: The application/pdf Media Type](/specs/IETF/RFC/8118 "The Portable Document Format (PDF) is an ISO standard (ISO 32000-1:2008) defining a final-form document representation language in use for document exchange, including on the Internet, since 1993. This document provides an overview of the PDF format and updates the media type registration of &#34;application/pdf&#34;.")
[`application/powder+xml`](/concepts/media-type/application/powder+xml "???") | [**W3C TR http://www.w3.org/TR/powder-dr**: Protocol for Web Description Resources (POWDER): Description Resources](/specs/W3C/TR/powder-dr "The purpose of the Protocol for Web Description Resources (POWDER) is to provide a means for individuals or organizations to describe a group of resources through the publication of machine-readable metadata, as motivated by the POWDER Use Cases. This document details the creation and lifecycle of Description Resources (DRs), which encapsulate such metadata. These are typically represented in a highly constrained XML dialect that is relatively human-readable. The meaning of such DRs are underpinned by formal semantics, accessible by performing a GRDDL Transform.")
[`application/powder-s+xml`](/concepts/media-type/application/powder-s+xml "???") | [**W3C TR http://www.w3.org/TR/powder-dr**: Protocol for Web Description Resources (POWDER): Description Resources](/specs/W3C/TR/powder-dr "The purpose of the Protocol for Web Description Resources (POWDER) is to provide a means for individuals or organizations to describe a group of resources through the publication of machine-readable metadata, as motivated by the POWDER Use Cases. This document details the creation and lifecycle of Description Resources (DRs), which encapsulate such metadata. These are typically represented in a highly constrained XML dialect that is relatively human-readable. The meaning of such DRs are underpinned by formal semantics, accessible by performing a GRDDL Transform.")
[`application/problem+json`](/concepts/media-type/application/problem+json "The canonical model for problem details is a JSON object. When serialised as a JSON document, that format is identified with the &#34;application/problem+json&#34; media type.") | [**RFC 7807**: Problem Details for HTTP APIs](/specs/IETF/RFC/7807 "This document defines a &#34;problem detail&#34; as a way to carry machine-readable details of errors in a HTTP response, to avoid the need to invent new error response formats for HTTP APIs.")
[`application/problem+xml`](/concepts/media-type/application/problem+xml "Some HTTP-based APIs use XML as their primary format convention. Such APIs MAY express problem details using the format defined in this appendix.") | [**RFC 7807**: Problem Details for HTTP APIs](/specs/IETF/RFC/7807 "This document defines a &#34;problem detail&#34; as a way to carry machine-readable details of errors in a HTTP response, to avoid the need to invent new error response formats for HTTP APIs.")
[`application/rdf+json`](/concepts/media-type/application/rdf+json "An RDF Graph consists of a set of RDF triples, each triple consisting of a subject, a predicate and an object. An RDF/JSON document serializes such a set of RDF triples as a series of nested data structures. A conforming RDF/JSON document consists of a single JSON object called the root object. Each unique subject in the set of triples is represented as a key in the root object. No key may appear more than once in the root object. The value of each root object key is a further JSON object whose keys are the URIs of the predicates occurring in triples with the given subject. These keys are known as predicate keys. No predicate key may appear more than once within a single object. The value of each predicate key is an array of JSON objects representing the object of each serialized triple.") | [**W3C TR http://www.w3.org/TR/json-rdf**: RDF 1.1 JSON Alternate Serialization (RDF/JSON)](/specs/W3C/TR/json-rdf "The Resource Description Framework (RDF) is a framework for representing information in the Web. This document defines a textual syntax for RDF called RDF/JSON that allows an RDF graph to be completely written in a form compatible with the JavaScript Object Notation (JSON) and alternative to the one recommended in JSON-LD. The syntax defined in this document should not be used unless there is a specific reason to do so. Use of JSON-LD is recommended.")
[`application/rdf+xml`](/concepts/media-type/application/rdf+xml "RDF is a language designed to support the Semantic Web, by facilitating resource description and data exchange on the Web. RDF provides common structures that can be used for interoperable data exchange and follows the W3C design principles of interoperability, evolution, and decentralization. While the RDF data model can be serialized in many ways, the W3C has defined the RDF/XML syntax to allow RDF to be serialized in an XML format. The application/rdf+xml media type allows RDF consumers to identify RDF/XML documents so that they can be processed properly.") | [**RFC 3870**: application/rdf+xml Media Type Registration](/specs/IETF/RFC/3870 "This document describes a media type (application/rdf+xml) for use with the Extensible Markup Language (XML) serialization of the Resource Description Framework (RDF). RDF is a language designed to support the Semantic Web, by facilitating resource description and data exchange on the Web. RDF provides common structures that can be used for interoperable data exchange and follows the World Wide Web Consortium (W3C) design principles of interoperability, evolution, and decentralization.")
[`application/rfc+xml`](/concepts/media-type/application/rfc+xml "This document updates the specification for the Internet media type &#34;application/rfc+xml&#34; from the one in I-D draft-reschke-xml2rfc.  The following is to be registered with IANA.") | [**Internet Draft hoffman-xml2rfc**: The 'XML2RFC' version 3 Vocabulary](/specs/IETF/I-D/hoffman-xml2rfc "This document defines the &#34;XML2RFC&#34; version 3 vocabulary; an XML-based language used for writing RFCs and Internet-Drafts. It is heavily derived from the version 2 vocabulary that is also under discussion. This document obsoletes the v2 grammar described in RFC 2629 and its expected followup, draft-reschke-xml2rfc.")
[`application/samlassertion+xml`](/concepts/media-type/application/samlassertion+xml "This document defines a MIME media type for use with the XML serialization of SAML (Security Assertion Markup Language) assertions.") | [**OASIS Standard saml-bindings-2.0-os**: Bindings for the OASIS Security Assertion Markup Language (SAML) V2.0](/specs/OASIS/standard/saml-bindings-2.0-os "This specification defines protocol bindings for the use of SAML assertions and request-response messages in communications protocols and frameworks.")
[`application/samlmetadata+xml`](/concepts/media-type/application/samlmetadata+xml "This document defines a MIME media type  for use with the XML serialization of Security Assertion Markup Language metadata.") | [**OASIS Standard saml-metadata-2.0-os**: Metadata for the OASIS Security Assertion Markup Language (SAML) V2.0](/specs/OASIS/standard/saml-metadata-2.0-os "SAML profiles require agreements between system entities regarding identifiers, binding support and endpoints, certificates and keys, and so forth. A metadata specification is useful for describing this information in a standardized way. This document defines an extensible metadata format for SAML system entities, organized by roles that reflect SAML profiles. Such roles include that of Identity Provider, Service Provider, Affiliation, Attribute Authority, Attribute Consumer, and Policy Decision Point.")
[`application/scim+json`](/concepts/media-type/application/scim+json "The &#34;application/scim+json&#34; media type is intended to identify JSON structure data that conforms to the SCIM protocol and schema specifications.") | [**RFC 7644**: System for Cross-domain Identity Management: Protocol](/specs/IETF/RFC/7644 "The System for Cross-domain Identity Management (SCIM) specification is an HTTP-based protocol that makes managing identities in multi-domain scenarios easier to support via a standardized service. Examples include, but are not limited to, enterprise-to-cloud service providers and inter-cloud scenarios.  The specification suite seeks to build upon experience with existing schemas and deployments, placing specific emphasis on simplicity of development and integration, while applying existing authentication, authorization, and privacy models.  SCIM's intent is to reduce the cost and complexity of user management operations by providing a common user schema, an extension model, and a service protocol defined by this document.")
[`application/secevent+jwt`](/concepts/media-type/application/secevent+jwt "This specification registers the &#34;application/secevent+jwt&#34; media type, which can be used to indicate that the content is a SET. SETs MAY include this media type in the &#34;typ&#34; header parameter of the JWT representing the SET to explicitly declare that the JWT is a SET. This MUST be included if the SET could be used in an application context in which it could be confused with other kinds of JWTs.") | [**RFC 8417**: Security Event Token (SET)](/specs/IETF/RFC/8417 "This specification defines the Security Event Token (SET) data structure. A SET describes statements of fact from the perspective of an issuer about a subject. These statements of fact represent an event that occurred directly to or about a security subject, for example, a statement about the issuance or revocation of a token on behalf of a subject. This specification is intended to enable representing security- and identity-related events. A SET is a JSON Web Token (JWT), which can be optionally signed and/or encrypted. SETs can be distributed via protocols such as HTTP.")
[`application/senml+cbor`](/concepts/media-type/application/senml+cbor "SenML is defined by a data model for measurements and simple meta-data about measurements and devices. The data is structured as a single array that contains a series of SenML Records which can each contain attributes such as an unique identifier for the sensor, the time the measurement was made, the unit the measurement is in, and the current value of the sensor.") | [**Internet Draft ietf-core-senml**: Media Types for Sensor Measurement Lists (SenML)](/specs/IETF/I-D/ietf-core-senml "This specification defines media types for representing simple sensor measurements and device parameters in the Sensor Measurement Lists (SenML). Representations are defined in JavaScript Object Notation (JSON), Concise Binary Object Representation (CBOR), eXtensible Markup Language (XML), and Efficient XML Interchange (EXI), which share the common SenML data model. A simple sensor, such as a temperature sensor, could use this media type in protocols such as HTTP or CoAP to transport the measurements of the sensor or to be configured.")
[`application/senml+exi`](/concepts/media-type/application/senml+exi "SenML is defined by a data model for measurements and simple meta-data about measurements and devices. The data is structured as a single array that contains a series of SenML Records which can each contain attributes such as an unique identifier for the sensor, the time the measurement was made, the unit the measurement is in, and the current value of the sensor.") | [**Internet Draft ietf-core-senml**: Media Types for Sensor Measurement Lists (SenML)](/specs/IETF/I-D/ietf-core-senml "This specification defines media types for representing simple sensor measurements and device parameters in the Sensor Measurement Lists (SenML). Representations are defined in JavaScript Object Notation (JSON), Concise Binary Object Representation (CBOR), eXtensible Markup Language (XML), and Efficient XML Interchange (EXI), which share the common SenML data model. A simple sensor, such as a temperature sensor, could use this media type in protocols such as HTTP or CoAP to transport the measurements of the sensor or to be configured.")
[`application/senml+json`](/concepts/media-type/application/senml+json "SenML is defined by a data model for measurements and simple meta-data about measurements and devices. The data is structured as a single array that contains a series of SenML Records which can each contain attributes such as an unique identifier for the sensor, the time the measurement was made, the unit the measurement is in, and the current value of the sensor.") | [**Internet Draft ietf-core-senml**: Media Types for Sensor Measurement Lists (SenML)](/specs/IETF/I-D/ietf-core-senml "This specification defines media types for representing simple sensor measurements and device parameters in the Sensor Measurement Lists (SenML). Representations are defined in JavaScript Object Notation (JSON), Concise Binary Object Representation (CBOR), eXtensible Markup Language (XML), and Efficient XML Interchange (EXI), which share the common SenML data model. A simple sensor, such as a temperature sensor, could use this media type in protocols such as HTTP or CoAP to transport the measurements of the sensor or to be configured.")
[`application/senml+xml`](/concepts/media-type/application/senml+xml "SenML is defined by a data model for measurements and simple meta-data about measurements and devices. The data is structured as a single array that contains a series of SenML Records which can each contain attributes such as an unique identifier for the sensor, the time the measurement was made, the unit the measurement is in, and the current value of the sensor.") | [**Internet Draft ietf-core-senml**: Media Types for Sensor Measurement Lists (SenML)](/specs/IETF/I-D/ietf-core-senml "This specification defines media types for representing simple sensor measurements and device parameters in the Sensor Measurement Lists (SenML). Representations are defined in JavaScript Object Notation (JSON), Concise Binary Object Representation (CBOR), eXtensible Markup Language (XML), and Efficient XML Interchange (EXI), which share the common SenML data model. A simple sensor, such as a temperature sensor, could use this media type in protocols such as HTTP or CoAP to transport the measurements of the sensor or to be configured.")
[`application/sgml`](/concepts/media-type/application/sgml "Use the Application/SGML media-type for SGML text entities that are not appropriate for Text/SGML.") | [**RFC 1874**: SGML Media Types](/specs/IETF/RFC/1874 "This document proposes new media sub-types of Text/SGML and Application/SGML. These media types can be used in the exchange of SGML documents and their entities. Specific details for the exchange or encapsulation of groups of related SGML entities using MIME are currently being considered by the mimesgml Working Group.")
[`application/soap+xml`](/concepts/media-type/application/soap+xml "This specification defines the media type &#34;application/soap+xml&#34; which can be used to identify SOAP 1.2 message envelopes that have been serialized with XML 1.0.") | [**RFC 3902**: The "application/soap+xml" Media Type](/specs/IETF/RFC/3902 "This document defines the &#34;application/soap+xml&#34; media type which can be used to describe SOAP 1.2 messages serialized as XML 1.0.")
[`application/sql`](/concepts/media-type/application/sql "The Structured Query Language (SQL) has been in use for over 30 years with various types of database technologies.") | [**RFC 6922**: The application/sql Media Type](/specs/IETF/RFC/6922 "This document registers the application/sql media type to be used for the Structured Query Language (SQL).")
[`application/sru+xml`](/concepts/media-type/application/sru+xml "An XML schema for the SRU response. SRU is a protocol, and the media type sru+xml pertains specifically to the default SRU response. The SRU response may be supplied in any of a number of suitable schemas, RSS, ATOM, for example, and the client identifies the desired format in the request, hence the need for a media type.") | [**RFC 6207**: The Media Types application/mods+xml, application/mads+xml, application/mets+xml, application/marcxml+xml, and application/sru+xml](/specs/IETF/RFC/6207 "This document specifies media types for the following formats: MODS (Metadata Object Description Schema), MADS (Metadata Authority Description Schema), METS (Metadata Encoding and Transmission Standard), MARCXML (MARC21 XML Schema), and the SRU (Search/Retrieve via URL Response Format) protocol response XML schema. These are all XML schemas providing representations of various forms of information including metadata and search results.")
[`application/tracking-status+json`](/concepts/media-type/application/tracking-status+json "For each tracking status resource, an origin server MUST provide a valid representation using the application/tracking-status+json media type. This media type consists of a status object serialized as JSON.") | [**W3C TR http://www.w3.org/TR/tracking-dnt**: Tracking Preference Expression (DNT)](/specs/W3C/TR/tracking-dnt "This specification defines the technical mechanisms for expressing a tracking preference via the DNT request header field in HTTP, via an HTML DOM property readable by embedded scripts, and via properties accessible to various user agent plug-in or extension APIs. It also defines mechanisms for sites to signal whether and how they honor this preference, both in the form of a machine-readable tracking status resource at a well-known location and via a &#34;Tk&#34; response header field, and a mechanism for allowing the user to approve exceptions to DNT as desired.")
[`application/trig`](/concepts/media-type/application/trig "A TriG document allows writing down an RDF Dataset in a compact textual form. It consists of a sequence of directives, triple statements, graph statements which contain triple-generating statements and optional blank lines. Comments may be given after a # that is not part of another lexical token and continue to the end of the line.") | [**W3C TR http://www.w3.org/TR/trig**: TriG](/specs/W3C/TR/trig "The Resource Description Framework (RDF) is a general-purpose language for representing information in the Web. This document defines a textual syntax for RDF called TriG that allows an RDF dataset to be completely written in a compact and natural text form, with abbreviations for common usage patterns and datatypes. TriG is an extension of the Turtle [turtle] format.")
[`application/vcard+xml`](/concepts/media-type/application/vcard+xml "The MIME media type for use with vCard-in-XML data.") | [**RFC 6351**: xCard: vCard XML Representation](/specs/IETF/RFC/6351 "This document defines the XML schema of the vCard data format.")
[`application/vnd.apple.mpegurl`](/concepts/media-type/application/vnd.apple.mpegurl "The &#34;application/vnd.apple.mpegurl&#34; media type identifies Playlist files used by HTTP Live Streaming. The format of the Playlist files is derived from the M3U playlist file format and inherits two tags from that earlier file format: EXTM3U and EXTINF.") | [**RFC 8216**: HTTP Live Streaming](/specs/IETF/RFC/8216 "This document describes a protocol for transferring unbounded streams of multimedia data. It specifies the data format of the files and the actions to be taken by the server (sender) and the clients (receivers) of the streams. It describes version 7 of this protocol.")
[`application/vnd.health+json`](/concepts/media-type/application/vnd.health+json "An API Health Response Format (or, interchangeably, &#34;health check response&#34;) uses the format described in RFC 8259 and has the media type &#34;application/vnd.health+json&#34;. Its content consists of a single mandatory root field (&#34;status&#34;) and several optional fields.") | [**Internet Draft inadarei-api-health-check**: Health Check Response Format for HTTP APIs](/specs/IETF/I-D/inadarei-api-health-check "This document proposes a service health check response format for HTTP APIs.")
[`application/webpush-options+json`](/concepts/media-type/application/webpush-options+json "The user agent includes the public key of the application server when requesting the creation of a push subscription. The public key is then added to the request to create a push subscription. The push subscription request is extended to include a body. The body of the request is a JSON object. A &#34;vapid&#34; member is added to this JSON object, containing the public key on the P-256 curve, encoded in the uncompressed form and base64url encoded.") | [**Internet Draft ietf-webpush-vapid**: Voluntary Application Server Identification (VAPID) for Web Push](/specs/IETF/I-D/ietf-webpush-vapid "An application server can use the method described to voluntarily identify itself to a push service. This identification information can be used by the push service to attribute requests that are made by the same application server to a single entity. An application server can include additional information that the operator of a push service can use to contact the operator of the application server. This identification information can be used to restrict the use of a push subscription a single application server.")
[`application/xhtml+xml`](/concepts/media-type/application/xhtml+xml "This specification defines an abstract language for describing documents and applications, and some APIs for interacting with in-memory representations of resources that use this language. The second concrete syntax is the XHTML syntax, which is an application of XML. This specification defines the latest version of the XHTML syntax, known as &#34;XHTML 5.1&#34;.") | [**W3C TR http://www.w3.org/TR/html**: Hypertext Markup Language (HTML)](/specs/W3C/TR/html "This specification defines the 5th major version, second minor revision of the core language of the World Wide Web: the Hypertext Markup Language (HTML). In this version, new features continue to be introduced to help Web application authors, new elements continue to be introduced based on research into prevailing authoring practices, and special attention continues to be given to defining clear conformance criteria for user agents in an effort to improve interoperability.")
[`application/xliff+xml`](/concepts/media-type/application/xliff+xml "XLIFF is the XML Localization Interchange File Format designed by a group of multilingual content publishers, software providers, localization service providers, localization tools providers and researchers. It is intended to give any multilingual content owner a single interchange file format that can be understood by any localization provider, using any conformant localization tool.") | [**OASIS Standard xliff-core-v2.1**: XLIFF Version 2.1](/specs/OASIS/standard/xliff-core-v2.1 "This document defines version 2.1 of the XML Localization Interchange File Format (XLIFF). The purpose of this vocabulary is to store localizable data and carry it from one step of the localization process to the other, while allowing interoperability between and among tools.")
[`application/xml`](/concepts/media-type/application/xml "The media types application/xml or text/xml, or a more specific media type, SHOULD be used for XML document entities.") | [**RFC 7303**: XML Media Types](/specs/IETF/RFC/7303 "This specification standardizes three media types - application/xml, application/xml-external-parsed-entity, and application/xml-dtd - for use in exchanging network entities that are related to the Extensible Markup Language (XML) while defining text/xml and text/xml-external-parsed-entity as aliases for the respective application/ types. This specification also standardizes the '+xml' suffix for naming media types outside of these five types when those media types represent XML MIME entities.")
[`application/xml-dtd`](/concepts/media-type/application/xml-dtd "The media types application/xml-external-parsed-entity or text/xml-external-parsed-entity SHOULD be used for XML external parsed entities.") | [**RFC 7303**: XML Media Types](/specs/IETF/RFC/7303 "This specification standardizes three media types - application/xml, application/xml-external-parsed-entity, and application/xml-dtd - for use in exchanging network entities that are related to the Extensible Markup Language (XML) while defining text/xml and text/xml-external-parsed-entity as aliases for the respective application/ types. This specification also standardizes the '+xml' suffix for naming media types outside of these five types when those media types represent XML MIME entities.")
[`application/xml-external-parsed-entity`](/concepts/media-type/application/xml-external-parsed-entity "The media type application/xml-dtd SHOULD be used for XML external DTD subsets.") | [**RFC 7303**: XML Media Types](/specs/IETF/RFC/7303 "This specification standardizes three media types - application/xml, application/xml-external-parsed-entity, and application/xml-dtd - for use in exchanging network entities that are related to the Extensible Markup Language (XML) while defining text/xml and text/xml-external-parsed-entity as aliases for the respective application/ types. This specification also standardizes the '+xml' suffix for naming media types outside of these five types when those media types represent XML MIME entities.")
[`application/xml-patch+xml`](/concepts/media-type/application/xml-patch+xml "The Internet media type for an XML Patch Document is application/xml-patch+xml.") | [**RFC 7351**: A Media Type for XML Patch Operations](/specs/IETF/RFC/7351 "The XML Patch media type &#34;application/xml-patch+xml&#34; defines an XML document structure for expressing a sequence of patch operations that are applied to an XML document. The XML Patch document format's foundations are defined in RFC 5261, this specification defines a document format and a media type registration, so that XML Patch documents can be labeled with a media type, for example in HTTP conversations. In addition to the media type registration, this specification also updates RFC 5261 in some aspects, limiting these updates to cases where RFC 5261 needed to be fixed, or was hard to understand.")
[`application/yaml`](/concepts/media-type/application/yaml "YAML is a data serialization format that is capable of conveying one or multiple documents in a single presentation stream (e.g., a file or a network resource). The media type for YAML is application/yaml") | [**RFC 9512**: YAML Media Type](/specs/IETF/RFC/9512 "This document registers the application/yaml media type and the +yaml structured syntax suffix with IANA. Both identify document components that are serialized according to the YAML specification.")
[`application/zlib`](/concepts/media-type/application/zlib "The 'application/zlib' media type describes a block of data that is compressed using zlib compression. The data is a stream of bytes as described in RFC 1950.") | [**RFC 6713**: The 'application/zlib' and 'application/gzip' Media Types](/specs/IETF/RFC/6713 "This document defines the 'application/gzip' and 'application/zlib' media types for compressed data using the gzip and zlib compression formats.")
[`font/collection`](/concepts/media-type/font/collection "ISO/IEC 14496-22 &#34;Open Font Format&#34; (OFF) specification being developed by ISO/IEC SC29/WG11.") | [**RFC 8081**: The "font" Top-Level Media Type](/specs/IETF/RFC/8081 "This memo serves to register and document the &#34;font&#34; top-level media type, under which subtypes for representation formats for fonts may be registered. This document also serves as a registration application for a set of intended subtypes, which are representative of some existing subtypes already in use, and currently registered under the &#34;application&#34; tree by their separate registrations.")
[`font/otf`](/concepts/media-type/font/otf "ISO/IEC 14496-22 &#34;Open Font Format&#34; (OFF) specification being developed by ISO/IEC SC29/WG11.") | [**RFC 8081**: The "font" Top-Level Media Type](/specs/IETF/RFC/8081 "This memo serves to register and document the &#34;font&#34; top-level media type, under which subtypes for representation formats for fonts may be registered. This document also serves as a registration application for a set of intended subtypes, which are representative of some existing subtypes already in use, and currently registered under the &#34;application&#34; tree by their separate registrations.")
[`font/sfnt`](/concepts/media-type/font/sfnt "Note that &#34;font/sfnt&#34; is an abstract type from which the (widely used in practice) &#34;font/ttf&#34; and &#34;font/otf&#34; types are conceptually derived. Use of &#34;font/sfnt&#34; is likely to be rare in practice.") | [**RFC 8081**: The "font" Top-Level Media Type](/specs/IETF/RFC/8081 "This memo serves to register and document the &#34;font&#34; top-level media type, under which subtypes for representation formats for fonts may be registered. This document also serves as a registration application for a set of intended subtypes, which are representative of some existing subtypes already in use, and currently registered under the &#34;application&#34; tree by their separate registrations.")
[`font/ttf`](/concepts/media-type/font/ttf "ISO/IEC 14496-22 &#34;Open Font Format&#34; (OFF) specification being developed by ISO/IEC SC29/WG11.") | [**RFC 8081**: The "font" Top-Level Media Type](/specs/IETF/RFC/8081 "This memo serves to register and document the &#34;font&#34; top-level media type, under which subtypes for representation formats for fonts may be registered. This document also serves as a registration application for a set of intended subtypes, which are representative of some existing subtypes already in use, and currently registered under the &#34;application&#34; tree by their separate registrations.")
[`font/woff`](/concepts/media-type/font/woff "WOFF is used by web browsers, often in conjunction with HTML and CSS.") | [**RFC 8081**: The "font" Top-Level Media Type](/specs/IETF/RFC/8081 "This memo serves to register and document the &#34;font&#34; top-level media type, under which subtypes for representation formats for fonts may be registered. This document also serves as a registration application for a set of intended subtypes, which are representative of some existing subtypes already in use, and currently registered under the &#34;application&#34; tree by their separate registrations.")
[`font/woff2`](/concepts/media-type/font/woff2 "WOFF 2.0 is used by web browsers, often in conjunction with HTML and CSS. WOFF 2.0 is an improvement on WOFF 1.0.  The two formats have different Internet Media Types and different @font-face formats, and they may be used in parallel.")<sub title="There are 2 definitions for this value">2</sub> | [**RFC 8081**: The "font" Top-Level Media Type](/specs/IETF/RFC/8081 "This memo serves to register and document the &#34;font&#34; top-level media type, under which subtypes for representation formats for fonts may be registered. This document also serves as a registration application for a set of intended subtypes, which are representative of some existing subtypes already in use, and currently registered under the &#34;application&#34; tree by their separate registrations.")<br/>[**W3C TR http://www.w3.org/TR/WOFF2**: WOFF File Format 2.0](/specs/W3C/TR/WOFF2 "Based on experience with WOFF 1.0, which is widely deployed, this specification was developed to provide improved compression and thus lower use of network bandwidth, while still allowing fast decompression even on mobile devices. This is achieved by combining a content-aware preprocessing step and improved entropy coding, compared to the Flate compression used in WOFF 1.0.")
[`image/jpeg`](/concepts/media-type/image/jpeg "JPEG File Interchange Format is a minimal file format which enables JPEG bitstreams to be exchanged between a wide variety of platforms and applications. This minimal format does not include any of the advanced features found in the TIFF JPEG specification or any application specific file format. Nor should it, for the only purpose of this simplified format is to allow the exchange of JPEG compressed images.") | [**ISO/IEC 10918**: Information technology — Digital compression and coding of continuous-tone still images: JPEG File Interchange Format (JFIF) ](/specs/ISO/IEC/10918 "The JPEG File Interchange Format (JFIF) is a minimal file format which enables the exchange of JPEG encoded images (according to Rec. ITU-T T.81 / ISO/IEC 10918-1) having 1 or 3 colour channels and 8 bits per colour channel between a wide variety of platforms and applications. This minimal format does not include some advanced features found in various other specified file formats. The purpose of this format is to provide for a basic form of exchange of JPEG images. The optional inclusion of thumbnail images for rapid browsing is also supported.")
[`image/png`](/concepts/media-type/image/png "PNG (Portable Network Graphics) is an extensible file format for the lossless, portable, well-compressed storage of raster images. PNG provides a patent-free replacement for GIF and can also replace many common uses of TIFF. Indexed-color, grayscale, and truecolor images are supported, plus an optional alpha channel. Sample depths range from 1 to 16 bits. PNG is designed to work well in online viewing applications, such as the World Wide Web, so it is fully streamable with a progressive display option. PNG is robust, providing both full file integrity checking and simple detection of common transmission errors. Also, PNG can store gamma and chromaticity data for improved color matching on heterogeneous platforms.") | [**W3C TR http://www.w3.org/TR/PNG**: Portable Network Graphics](/specs/W3C/TR/PNG "This document describes PNG (Portable Network Graphics), an extensible file format for the lossless, portable, well-compressed storage of raster images. PNG provides a patent-free replacement for GIF and can also replace many common uses of TIFF. Indexed-color, grayscale, and truecolor images are supported, plus an optional alpha channel. Sample depths range from 1 to 16 bits. PNG is designed to work well in online viewing applications, such as the World Wide Web, so it is fully streamable with a progressive display option. PNG is robust, providing both full file integrity checking and simple detection of common transmission errors. Also, PNG can store gamma and chromaticity data for improved color matching on heterogeneous platforms.")
[`image/webp`](/concepts/media-type/image/webp "WebP is a Resource Interchange File Format (RIFF) based image file format which supports lossless and lossy compression as well as alpha (transparency) and animation.  It covers use cases similar to JPEG, PNG and the Graphics Interchange Format (GIF).") | [**Internet Draft zern-webp**: WebP Image Format](/specs/IETF/I-D/zern-webp "WebP is a RIFF-based image file format which supports lossless and lossy compression as well as alpha (transparency) and animation. It covers use cases similar to JPEG, PNG and GIF.")
[`message/bhttp`](/concepts/media-type/message/bhttp "This document defines a simple format for representing an HTTP message, either request or response. This allows for the encoding of HTTP messages that can be conveyed outside of an HTTP protocol. This enables the transformation of entire messages, including the application of authenticated encryption.") | [**Internet Draft ietf-httpbis-binary-message**: Binary Representation of HTTP Messages](/specs/IETF/I-D/ietf-httpbis-binary-message "This document defines a binary format for representing HTTP messages.")
[`message/http`](/concepts/media-type/message/http "The message/http type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all &#34;message&#34; types regarding line length and encodings.") | [**RFC 7230**: Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing](/specs/IETF/RFC/7230 "The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypertext information systems. HTTP has been in use by the World Wide Web global information initiative since 1990. This document provides an overview of HTTP architecture and its associated terminology, defines the &#34;http&#34; and &#34;https&#34; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes general security concerns for implementations.")
[`message/ohttp-req`](/concepts/media-type/message/ohttp-req "HTTP message encapsulation uses HPKE for request and response encryption. An Encapsulated Request is comprised of a length-prefixed key identifier and a HPKE-protected request message. HPKE protection includes an encapsulated KEM shared secret (or enc), plus the AEAD-protected request message.") | [**Internet Draft ietf-ohai-ohttp**: Oblivious HTTP](/specs/IETF/I-D/ietf-ohai-ohttp "This document describes a system for the forwarding of encrypted HTTP messages. This allows a client to make multiple requests of a server without the server being able to link those requests to the client or to identify the requests as having come from the same client.")
[`message/ohttp-res`](/concepts/media-type/message/ohttp-res "HTTP message encapsulation uses HPKE for request and response encryption. Responses are bound to responses and so consist only of AEAD-protected content.") | [**Internet Draft ietf-ohai-ohttp**: Oblivious HTTP](/specs/IETF/I-D/ietf-ohai-ohttp "This document describes a system for the forwarding of encrypted HTTP messages. This allows a client to make multiple requests of a server without the server being able to link those requests to the client or to identify the requests as having come from the same client.")
[`multipart/form-data`](/concepts/media-type/multipart/form-data "The media-type multipart/form-data follows the rules of all multipart MIME data streams as outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who fills out the form. Each field has a name. Within a given form, the names are unique.") | [**RFC 2388**: Returning Values from Forms: multipart/form-data](/specs/IETF/RFC/2388 "This specification defines an Internet Media Type, multipart/form-data, which can be used by a wide variety of applications and transported by a wide variety of protocols as a way of returning a set of values as the result of a user filling out a form.")
[`multipart/multilingual`](/concepts/media-type/multipart/multilingual "A 'multipart/multilingual' message will have a number of message parts: exactly one multilingual preface, one or more language message parts, and zero or one language-independent message part. The details of these are described below.") | [**RFC 8255**: Multiple Language Content Type](/specs/IETF/RFC/8255 "This document defines the 'multipart/multilingual' content type, which is an addition to the Multipurpose Internet Mail Extensions (MIME) standard. This content type makes it possible to send one message that contains multiple language versions of the same information. The translations would be identified by a language tag and selected by the email client based on a user's language settings.")
[`multipart/x-mixed-replace`](/concepts/media-type/multipart/x-mixed-replace "When a resource with the type multipart/x-mixed-replace is to be loaded in a browsing context, the user agent must parse the resource using the rules for multipart types.") | [**W3C TR http://www.w3.org/TR/html**: Hypertext Markup Language (HTML)](/specs/W3C/TR/html "This specification defines the 5th major version, second minor revision of the core language of the World Wide Web: the Hypertext Markup Language (HTML). In this version, new features continue to be introduced to help Web application authors, new elements continue to be introduced based on research into prevailing authoring practices, and special attention continues to be given to defining clear conformance criteria for user agents in an effort to improve interoperability.")
[`text/csv`](/concepts/media-type/text/csv "The comma separated values format (CSV) has been used for exchanging and converting data between various spreadsheet programs for quite some time.")<sub title="There are 2 definitions for this value">2</sub> | [**RFC 4180**: Common Format and MIME Type for Comma-Separated Values (CSV) Files](/specs/IETF/RFC/4180 "This RFC documents the format used for Comma-Separated Values (CSV) files and registers the associated MIME type &#34;text/csv&#34;.")<br/>[**RFC 7111**: URI Fragment Identifiers for the text/csv Media Type](/specs/IETF/RFC/7111 "This memo defines URI fragment identifiers for text/csv MIME entities. These fragment identifiers make it possible to refer to parts of a text/csv MIME entity identified by row, column, or cell. Fragment identification can use single items or ranges.")
[`text/ecmascript`](/concepts/media-type/text/ecmascript "This memo describes media types for the JavaScript and ECMAScript programming languages. The most widely supported media type in use is text/javascript; all others are considered historical and obsolete aliases of text/javascript.") | [**RFC 9239**: Updates to ECMAScript Media Types](/specs/IETF/RFC/9239 "This document describes the registration of media types for the ECMAScript and JavaScript programming languages and conformance requirements for implementations of these types. This document obsoletes RFC 4329 (&#34;Scripting Media Types)&#34;, replacing the previous registrations with information and requirements aligned with common usage and implementation experiences.")
[`text/event-stream`](/concepts/media-type/text/event-stream "Defines a media type for representing an event stream for Server-Sent Events.") | [**W3C TR http://www.w3.org/TR/eventsource**: Server-Sent Events](/specs/W3C/TR/eventsource " specification defines an API for opening an HTTP connection for receiving push notifications from a server in the form of DOM events. The API is designed such that it can be extended to work with other push notification schemes such as Push SMS.")
[`text/grammar-ref-list`](/concepts/media-type/text/grammar-ref-list "The body of the RECOGNIZE method of the MRCP protocol may contain a list of grammar URIs specified in content of media type 'text/grammar-ref-list'. This type defines a list of grammar URIs and allows each grammar URI to be assigned a weight in the list.") | [**RFC 6768**: Media Resource Control Protocol Version 2 (MRCPv2)](/specs/IETF/RFC/6768 "The Media Resource Control Protocol Version 2 (MRCPv2) allows client hosts to control media service resources such as speech synthesizers, recognizers, verifiers, and identifiers residing in servers on the network. MRCPv2 is not a &#34;stand-alone&#34; protocol -- it relies on other protocols, such as the Session Initiation Protocol (SIP), to coordinate MRCPv2 clients and servers and manage sessions between them, and the Session Description Protocol (SDP) to describe, discover, and exchange capabilities. It also depends on SIP and SDP to establish the media sessions and associated parameters between the media source or sink and the media server. Once this is done, the MRCPv2 exchange operates over the control session established above, allowing the client to control the media processing resources on the speech resource server.")
[`text/html`](/concepts/media-type/text/html "This specification defines an abstract language for describing documents and applications, and some APIs for interacting with in-memory representations of resources that use this language. The first such concrete syntax is the HTML syntax. This is the format suggested for most authors. It is compatible with most legacy Web browsers. This specification defines the latest version of the HTML syntax, known as &#34;HTML 5.1&#34;.") | [**W3C TR http://www.w3.org/TR/html**: Hypertext Markup Language (HTML)](/specs/W3C/TR/html "This specification defines the 5th major version, second minor revision of the core language of the World Wide Web: the Hypertext Markup Language (HTML). In this version, new features continue to be introduced to help Web application authors, new elements continue to be introduced based on research into prevailing authoring practices, and special attention continues to be given to defining clear conformance criteria for user agents in an effort to improve interoperability.")
[`text/javascript`](/concepts/media-type/text/javascript "This memo describes media types for the JavaScript and ECMAScript programming languages. The most widely supported media type in use is text/javascript; all others are considered historical and obsolete aliases of text/javascript.") | [**RFC 9239**: Updates to ECMAScript Media Types](/specs/IETF/RFC/9239 "This document describes the registration of media types for the ECMAScript and JavaScript programming languages and conformance requirements for implementations of these types. This document obsoletes RFC 4329 (&#34;Scripting Media Types)&#34;, replacing the previous registrations with information and requirements aligned with common usage and implementation experiences.")
[`text/markdown`](/concepts/media-type/text/markdown "This document registers the text/markdown media type for use with Markdown, a family of plain-text formatting syntaxes that optionally can be converted to formal markup languages such as HTML.") | [**RFC 7763**: The text/markdown Media Type](/specs/IETF/RFC/7763 "This document registers the text/markdown media type for use with Markdown, a family of plain-text formatting syntaxes that optionally can be converted to formal markup languages such as HTML.")
[`text/plain`](/concepts/media-type/text/plain "This memo updates the text/plain media type defined in RFC 2046  by defining URI fragment identifiers for text/plain MIME entities. This makes it possible to refer to parts of a text/plain MIME entity. Such parts can be identified by either character position or range, or by line position or range. Integrity checking information can be added to a fragment identifier to make it more robust, enabling applications to detect changes of the entity.") | [**RFC 5147**: URI Fragment Identifiers for the text/plain Media Type](/specs/IETF/RFC/5147 "This memo defines URI fragment identifiers for text/plain MIME entities. These fragment identifiers make it possible to refer to parts of a text/plain MIME entity, either identified by character position or range, or by line position or range. Fragment identifiers may also contain information for integrity checks to make them more robust.")
[`text/sgml`](/concepts/media-type/text/sgml "The Text/SGML media-type can be employed when the contents of the SGML entity is intended to be read by a human and is in a readily comprehensible form.") | [**RFC 1874**: SGML Media Types](/specs/IETF/RFC/1874 "This document proposes new media sub-types of Text/SGML and Application/SGML. These media types can be used in the exchange of SGML documents and their entities. Specific details for the exchange or encapsulation of groups of related SGML entities using MIME are currently being considered by the mimesgml Working Group.")
[`text/vcard`](/concepts/media-type/text/vcard "The text/vcard MIME content type (hereafter known as &#34;vCard&#34;) contains contact information, typically pertaining to a single contact or group of contacts. The content consists of one or more lines in the format given below.") | [**RFC 6350**: vCard Format Specification](/specs/IETF/RFC/6350 "This document defines the vCard data format for representing and exchanging a variety of information about individuals and other entities (e.g., formatted and structured name and delivery addresses, email address, multiple telephone numbers, photograph, logo, audio clips, etc.). This document obsoletes RFCs 2425, 2426, and 4770, and updates RFC 2739.")
[`text/vtt`](/concepts/media-type/text/vtt "The WebVTT (Web Video Text Tracks) format is intended for marking up external text track resources. The main use for WebVTT files is captioning or subtitling video content.") | [**W3C TR http://www.w3.org/TR/webvtt**: Web Video Text Tracks (WebVTT)](/specs/W3C/TR/webvtt "This specification defines WebVTT, the Web Video Text Tracks format. Its main use is for marking up external text track resources in connection with the HTML <track> element. WebVTT files provide captions or subtitles for video content, and also text video descriptions, chapters for content navigation, and more generally any form of metadata that is time-aligned with audio or video content.")
[`text/xml`](/concepts/media-type/text/xml "If an XML document - that is, the unprocessed, source XML document - is readable by casual users, text/xml is preferable to application/xml. MIME user agents (and web user agents) that do not have explicit support for text/xml will treat it as text/plain, for example, by displaying the XML MIME entity as plain text.") | [**RFC 3023**: XML Media Types](/specs/IETF/RFC/3023 "This document standardizes five new media types - text/xml, application/xml, text/xml-external-parsed-entity, application/xml-external-parsed-entity, and application/xml-dtd - for use in exchanging network entities that are related to the Extensible Markup Language (XML). This document also standardizes a convention (using the suffix '+xml') for naming media types outside of these five types when those media types represent XML MIME (Multipurpose Internet Mail Extensions) entities. XML MIME entities are currently exchanged via the HyperText Transfer Protocol on the World Wide Web, are an integral part of the WebDAV protocol for remote web authoring, and are expected to have utility in many domains.")
[`text/xml-external-parsed-entity`](/concepts/media-type/text/xml-external-parsed-entity "If an XML external parsed entity - that is, the unprocessed, source XML entity - is readable by casual users, text/xml-external-parsed-entity is preferable to application/xml-external-parsed-entity. MIME user agents (and web user agents) that do not have explicit support for text/xml-external-parsed-entity will treat it as text/plain, for example, by displaying the XML MIME entity as plain text.") | [**RFC 3023**: XML Media Types](/specs/IETF/RFC/3023 "This document standardizes five new media types - text/xml, application/xml, text/xml-external-parsed-entity, application/xml-external-parsed-entity, and application/xml-dtd - for use in exchanging network entities that are related to the Extensible Markup Language (XML). This document also standardizes a convention (using the suffix '+xml') for naming media types outside of these five types when those media types represent XML MIME (Multipurpose Internet Mail Extensions) entities. XML MIME entities are currently exchanged via the HyperText Transfer Protocol on the World Wide Web, are an integral part of the WebDAV protocol for remote web authoring, and are expected to have utility in many domains.")

<br/>
<hr/>

<p style="float : left"><a href="../media-type.json" title="JSON representing all values for this Web Concept">JSON</a></p>
